<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Australian Elections Visualisation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Vega, Vega-Lite, Vega-Embed pinned (Sankey requires Vega >= 5.28) -->
  <script src="https://cdn.jsdelivr.net/npm/vega@5.30.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@5.16.3"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6.24.0"></script>

  <link rel="stylesheet" href="styles.css?v=7" />
  <!-- Inline SVG favicon to avoid 404 for /favicon.ico -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='8' ry='8' fill='%2300447a'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='central' text-anchor='middle' font-family='Segoe UI, Roboto, Arial' font-size='30' fill='white'%3EAU%3C/text%3E%3C/svg%3E" />
</head>
<body>

  <header class="site-header">
    <div class="wrap">
      <section class="viz-section">
        <h1 class="site-title">Australia Votes: A Nation Divided and Engaged</h1>
        <p class="site-intro">This page brings the 2022 election into focus from several angles: a map of two party preferred results by division, turnout over time by state, a 100% stacked view of seats held by the majors, preference flows from minor parties to <span class="party-alp">Labour</span> or the <span class="party-coalition">Coalition</span>, and a state grid of income brackets by age. Together these views connect geography, participation and party competition. They matter because they translate complex election data into clear, everyday patterns that Australians can read at a glance. The map shows where support is concentrated, turnout trends reveal how engaged different places are, seat shares show who governed with real numbers, preference flows explain how our preferential system shapes final outcomes, and the income-age grid gives social context for those patterns. Sources are official (AEC for election results and ABS for Census data), and the visuals are designed to inform rather than persuade. They should help a general audience make sense of the 2022 result, compare it with recent years, and ask better questions about what changed and why.</p>
      </section>
    </div>
  </header>

  <div class="wrap">

    <!-- ===================== MAP VISUALISATION ===================== -->
    <section class="viz-section" id="tpp-map">
    <h1>Two-Party-Preferred (TPP), House of Representatives, 2022</h1>
    <div class="grid-two"><div class="text">
    <p>
      Colour shows % TPP relative to 50%.<br>
      Red &gt; 50% <strong class="party-alp">ALP</strong>; Blue &gt; 50% <strong class="party-coalition">Coalition</strong>. Hover for details.<br>
      Data: <a href="https://results.aec.gov.au/27966/website/HouseDownloadsMenu-27966-Csv.htm">AEC</a>,
      boundaries: <a href="https://data.gov.au/data/dataset/commonwealth-electoral-divisions-as-at-2-august-2021">data.gov.au</a>.
    </p>
    <p>The map shows how Australians voted in the 2022 federal election, comparing support for the two major political groups â€” the Australian <strong class="party-alp">Labor</strong> Party (<strong class="party-alp">ALP</strong>) and the Liberalâ€‘National <strong class="party-coalition">Coalition</strong>. Each electorate is coloured by the twoâ€‘partyâ€‘preferred result, which represents which of the two main sides received more votes after preferences were distributed. Shades of red indicate areas where <strong class="party-alp">Labor</strong> gained the majority, while shades of blue show where the <strong class="party-coalition">Coalition</strong> led. By looking across the country, we can see clear patterns: <strong class="party-alp">Labor</strong>'s strength is concentrated in urban and coastal regions, while the <strong class="party-coalition">Coalition</strong> continues to perform strongly in many rural areas. Together, these colours reveal the political landscape that shaped the 2022 outcome and the regional divides within Australia's democracy.</p>
    <p id="tpp-desc-clean">The map shows how Australians voted in the 2022 federal election, comparing support for the two major political groups - the Australian <strong class="party-alp">Labour</strong> Party (<strong class="party-alp">ALP</strong>) and the Liberal-National <strong class="party-coalition">Coalition</strong>. Each electorate is coloured by the two-party-preferred result, which represents which of the two main sides received more votes after preferences were distributed. Shades of red indicate areas where <strong class="party-alp">Labour</strong> gained the majority, while shades of blue show where the <strong class="party-coalition">Coalition</strong> led. By looking across the country, we can see clear patterns: <strong class="party-alp">Labour</strong>'s strength is concentrated in urban and coastal regions, while the <strong class="party-coalition">Coalition</strong> continues to perform strongly in many rural areas. Together, these colours reveal the political landscape that shaped the 2022 outcome and the regional divides within Australia's democracy.</p>
    </div><div class="chart">
    <div id="map-zoom-controls" aria-label="Map zoom controls">
      <label for="map-fit-state">Fit to:</label>
      <select id="map-fit-state" title="Fit view to state">
        <option value="AUS">Australia</option>
        <option value="NSW">NSW</option>
        <option value="VIC">VIC</option>
        <option value="QLD">QLD</option>
        <option value="WA">WA</option>
        <option value="SA">SA</option>
        <option value="TAS">TAS</option>
        <option value="ACT">ACT</option>
        <option value="NT">NT</option>
      </select>
      <button type="button" id="map-zoom-out" title="Zoom out">-</button>
      <button type="button" id="map-zoom-in" title="Zoom in">+</button>
      <button type="button" id="map-zoom-reset" title="Reset view">Reset</button>
    </div>
    <div id="vis"></div>
    </div></div></section>

    <!-- ===================== AGE x INCOME (STATE GRID) ===================== -->
    <section class="viz-section income-grid">
      <h2>Income brackets by age group (by state)</h2>
      <div class="grid-two"><div class="text">
        <p>Each panel shows a state/territory. Heatmap cells at Age group x Income bracket are colored by the number of people. Data is pre-binned for readability. Data: <a href="https://digital.atlas.gov.au/datasets/digitalatlas::abs-2021-census-g17-total-personal-income-weekly-by-age-by-sex-by-2021-lga/explore?location=-22.366853%2C132.407488%2C5.00" target="_blank" rel="noopener">ABS 2021 Census G17 (Digital Atlas)</a>.</p>
        <p class="three-col">This 3x3 heatmap compares Age group x Income brackets (columns) for each state and territory, plus Australia overall. A clear pattern appears across the country: younger people (15-24) cluster in the lowest income brackets, the mid-working years (25-54) concentrate in the middle brackets, and the share tapers for the highest brackets, especially in older ages. States with larger capital-city populations like NSW and VIC show a stronger middle-to-upper income band in the 25-54 range, while WA also presents a pronounced mid-to-upper band consistent with its resources economy. ACT skews relatively high across working ages, reflecting its public-sector wage profile, whereas NT shows a flatter spread and fewer cells in the highest brackets. Read alongside the choropleth map (the map above), which highlights where the two major political groups led by division, these income-age profiles hint at the different social and economic make-ups behind those geographic results: urbanised states with more mid-to-higher-income working-age residents map to the big city belts on the choropleth, while jurisdictions with broader spreads or lower average incomes align more with regional and remote areas. This does not claim causation, but it gives helpful context for interpreting the electoral landscape.</p>
      </div><div class="chart full-bleed">
        <div id="vis-age-income-grid" class="charts-grid">
          <div id="vis-age-income-NSW" class="chart-card"></div>
          <div id="vis-age-income-VIC" class="chart-card"></div>
          <div id="vis-age-income-QLD" class="chart-card"></div>
          <div id="vis-age-income-WA" class="chart-card"></div>
          <div id="vis-age-income-SA" class="chart-card"></div>
          <div id="vis-age-income-TAS" class="chart-card"></div>
          <div id="vis-age-income-ACT" class="chart-card"></div>
          <div id="vis-age-income-NT" class="chart-card"></div>
          <div id="vis-age-income-AUS" class="chart-card"></div>
        </div>
      </div></div>
    </section>

    <!-- ===================== TURNOUT LINE CHART ===================== -->
    <section class="viz-section">
    <h2>Voter turnout over time (filter by state)</h2>
    <div class="grid-two"><div class="text">
    <p>Use the dropdown to filter; choose &quot;All&quot; to show every state. Data: <a href="https://results.aec.gov.au/" target="_blank" rel="noopener">AEC</a>.</p>
    <p>The line chart tracks how voter turnout has changed across Australia's states and territories over recent federal elections. Each line represents one state or territory, showing the percentage of enrolled voters who cast a valid vote. While voting in Australia is compulsory, turnout still fluctuates slightly between elections and regions. Some areas, such as the <span class="state-NT">Northern Territory</span>, often record lower participation, partly due to distance and access to polling places. In contrast, states like <span class="state-VIC">Victoria</span> and <span class="state-NSW">New South Wales</span> tend to remain consistently high. Together, these trends reveal that even in a system where everyone must vote, levels of civic engagement can still vary  -  reflecting differences in demographics, access, and interest over time.</p>
    </div><div class="chart">
    <div id="vis-turnout"></div>
    </div></div></section>

    <!-- ===================== SEATS STACKED BAR ===================== -->
    <section class="viz-section">
      <h2>Seats by party (House of Representatives)</h2>
      <div class="grid-two"><div class="text">
        <p>Stacked bars show the total seats held by each major party at each election year. Data: <a href="https://results.aec.gov.au/" target="_blank" rel="noopener">AEC</a>.</p>
        <p>Across all elections shown, most seats are held by the two major blocs: the Australian <span class="party-alp">Labour</span> Party (ALP) and the Liberal-National <span class="party-coalition">Coalition</span>. This 100%-stacked bar chart compares their share of House seats by year. Columns are normalised to the two majors (crossbench seats are not shown), so each bar sums to 100% and the split indicates which side held more of the majors' seats in that year. The <span class="party-coalition">Coalition</span>'s share peaks in 2013, while <span class="party-alp">Labour</span>'s share lifts sharply in 2022. Read together with the choropleth map, this connects the national seat balance to the geographic patterns of support.</p>
      </div><div class="chart">
        <div id="vis-seats"></div>
      </div></div>
    </section>

    <!-- (Income brackets grid moved above, duplicate removed) -->

    <!-- ===================== PREFERENCE FLOWS (DUMBBELL) ===================== -->
    <section class="viz-section">
      <h2>Preference flows between parties</h2>
      <p>Dumbbell chart showing preference share to <span class="party-alp">Labour</span> vs <span class="party-coalition">Coalition</span>. Data: <a href="https://results.aec.gov.au/27966/Website/HouseStateTppFlow-27966-NAT.htm" target="_blank" rel="noopener">AEC TPP preference flows (2022)</a>.</p>
      <div class="grid-two"><div class="text">
        <p>In Australia's voting system, people number candidates in the order they prefer. If no one gets over 50% of first-preference votes, the candidate with the fewest is knocked out and those ballots move to the next choice. These movements are called <strong>preference flows</strong>. The dumbbell chart shows, for each minor party, what share of its voters' preferences flowed to <span class="party-alp">Labour</span> or to the <span class="party-coalition">Coalition</span>. Big picture: Greens preferences go mostly to <span class="party-alp">Labour</span> (around the mid-80s). Reason and Victorian Socialists are also strongly pro-<span class="party-alp">Labour</span>. Liberal Democrats, One Nation and United Australia preferences tend to flow to the <span class="party-coalition">Coalition</span> (about 60-70%). Remember this shows percentages of each party's preferences, not how many ballots they had in total.</p>
      </div><div class="chart">
        <div id="vis-sankey"></div>
      </div></div>
    </section>

  </div>

  <script>
  // ===================== MAP SPEC =====================
  const mapSpec = {
    "$schema": "https://vega.github.io/schema/vega-lite/v5.json",
    "width": 1000,
    "height": 700,
    "background": "white",
    "projection": { "type": "mercator", "center": [134, -26], "scale": 700 },

    "data": {
      "url": "data/ced_2021.geojson?v=2",
      "format": { "type": "json", "property": "features" }
    },

    "transform": [
      { "calculate": "datum.properties.Elect_div", "as": "DivisionNameGeo" },
      {
        "lookup": "DivisionNameGeo",
        "from": {
          "data": { "url": "data/tpp_2022.csv" },
          "key": "DivisionNm",
          "fields": [
            "Australian Labor Party Percentage",
            "Liberal/National Coalition Percentage",
            "StateAb"
          ]
        }
      },
      {
        "calculate": "isValid(datum['Australian Labor Party Percentage']) ? datum['Australian Labor Party Percentage'] - 50 : null",
        "as": "margin_alp"
      },
      {
        "calculate": "isValid(datum['Australian Labor Party Percentage']) ? (datum['Australian Labor Party Percentage'] >= 50 ? 'ALP' : 'Coalition') : 'No data'",
        "as": "winner"
      }
    ],

    "mark": { "type": "geoshape", "stroke": "#dddddd", "strokeWidth": 0.4 },

    "encoding": {
      "color": {
        "field": "margin_alp",
        "type": "quantitative",
        "title": "TPP margin (ALP Ã¢â‚¬â€œ 50%)",
        "scale": { "scheme": "redblue", "domain": [-20, 0, 20] },
        "legend": { "format": "+.0f", "labelExpr": "datum.value + '%'" }
      },
      "tooltip": [
        { "field": "DivisionNameGeo", "type": "nominal", "title": "Division" },
        { "field": "StateAb", "type": "nominal", "title": "State" },
        { "field": "winner", "type": "nominal", "title": "Winner" },
        { "field": "Australian Labor Party Percentage", "type": "quantitative", "title": "ALP TPP", "format": ".1f" },
        { "field": "Liberal/National Coalition Percentage", "type": "quantitative", "title": "Coalition TPP", "format": ".1f" }
      ]
    },

    "config": {
      "view": { "stroke": null },
      "legend": { "titleFontSize": 12, "labelFontSize": 11 }
    }
  };

  // Load smaller charts first and log any failures for debugging on GitHub Pages
  const loaderOpts = undefined; // not relying on loader baseURL; rewrite URLs to absolute
  const pageBase = new URL('./', window.location.href).href; // ensures trailing slash, e.g., .../hw9/

  async function fetchAndRewriteSpec(url) {
    const res = await fetch(url, { cache: "no-cache" });
    if (!res.ok) throw new Error(`Failed to fetch spec ${url}: ${res.status}`);
    const spec = await res.json();
    const rewrite = (node) => {
      if (!node || typeof node !== "object") return;
      for (const k of Object.keys(node)) {
        const v = node[k];
        if (k === "url" && typeof v === "string") {
          let p = v;
          if (p.startsWith("../data/")) {
            p = p.replace("../data/", "data/");
          }
          if (p.startsWith("data/")) {
            try {
              node[k] = new URL(p, pageBase).href;
            } catch (_) {
              node[k] = p;
            }
          }
        } else if (typeof v === "object") {
          rewrite(v);
        }
      }
    };
    rewrite(spec);
    return spec;
  }

  fetchAndRewriteSpec("specs/turnout.json?v=2")
    .then(spec => vegaEmbed("#vis-turnout", spec, { actions: false, loader: loaderOpts }))
    .catch(err => console.error("turnout embed error", err));

  fetchAndRewriteSpec("specs/seats_stacked.json?v=6")
    .then(spec => vegaEmbed("#vis-seats", spec, { actions: false, loader: loaderOpts }))
    .catch(err => console.error("seats embed error", err));

  // Inline dumbbell spec (no external fetch) using inlined data
  try {
    const flowDumbbellSpec = {
      $schema: "https://vega.github.io/schema/vega-lite/v5.json",
      description: "Preference flows to ALP vs Coalition by minor party (dumbbell).",
      autosize: { type: "fit-x", contains: "padding" },
      width: 990,
      height: 420,
      background: "white",
      data: {
        values: [
          { source: "Greens", ALP: 85.66, Coalition: 14.34 },
          { source: "United Australia Party", ALP: 38.14, Coalition: 61.86 },
          { source: "Pauline Hanson's One Nation", ALP: 35.70, Coalition: 64.30 },
          { source: "Independents", ALP: 63.77, Coalition: 36.23 },
          { source: "Katter's Australian Party", ALP: 38.69, Coalition: 61.31 },
          { source: "Liberal Democratic Party", ALP: 28.19, Coalition: 71.81 },
          { source: "Centre Alliance", ALP: 60.24, Coalition: 39.76 },
          { source: "Animal Justice Party", ALP: 63.71, Coalition: 36.29 },
          { source: "Legalise Cannabis Australia", ALP: 57.28, Coalition: 42.72 },
          { source: "Reason Australia", ALP: 80.73, Coalition: 19.27 },
          { source: "Victorian Socialists", ALP: 83.45, Coalition: 16.55 },
          { source: "Shooters Fishers and Farmers Party", ALP: 41.39, Coalition: 58.61 },
          { source: "Jacqui Lambie Network", ALP: 59.09, Coalition: 40.91 }
        ]
      },
      transform: [
        { calculate: "datum.ALP", as: "alp_pct" },
        { calculate: "datum['Coalition']", as: "coal_pct" },
        { calculate: "datum.alp_pct < datum.coal_pct ? datum.alp_pct : datum.coal_pct", as: "xMin" },
        { calculate: "datum.alp_pct > datum.coal_pct ? datum.alp_pct : datum.coal_pct", as: "xMax" },
        { fold: ["ALP", "Coalition"], as: ["target", "pct"] }
      ],
      layer: [
        {
          mark: { type: "rule", stroke: "#9aa0a6", strokeWidth: 2 },
          encoding: {
            y: { field: "source", type: "nominal", title: null, sort: { field: "alp_pct", order: "descending" } },
            x: { field: "xMin", type: "quantitative", title: "Preference share (%)", scale: { domain: [0, 100] }, axis: { format: ".0f" } },
            x2: { field: "xMax" }
          }
        },
        {
          transform: [ { filter: "datum.target == 'ALP'" } ],
          mark: { type: "point", filled: true, size: 90, stroke: "white", strokeWidth: 1.5 },
          encoding: {
            y: { field: "source", type: "nominal", sort: { field: "alp_pct", order: "descending" } },
            x: { field: "pct", type: "quantitative" },
            color: { value: "#d32f2f" },
            tooltip: [
              { field: "source", type: "nominal", title: "Minor party" },
              { field: "alp_pct", type: "quantitative", title: "To ALP", format: ".2f" },
              { field: "coal_pct", type: "quantitative", title: "To Coalition", format: ".2f" }
            ]
          }
        },
        {
          transform: [ { filter: "datum.target == 'Coalition'" } ],
          mark: { type: "point", filled: true, size: 90, stroke: "white", strokeWidth: 1.5 },
          encoding: {
            y: { field: "source", type: "nominal", sort: { field: "alp_pct", order: "descending" } },
            x: { field: "pct", type: "quantitative" },
            color: { value: "#1976d2" },
            tooltip: [
              { field: "source", type: "nominal", title: "Minor party" },
              { field: "alp_pct", type: "quantitative", title: "To ALP", format: ".2f" },
              { field: "coal_pct", type: "quantitative", title: "To Coalition", format: ".2f" }
            ]
          }
        }
      ],
      config: {
        view: { stroke: null },
        axis: { labelFontSize: 11, titleFontSize: 12 }
      }
    };
    vegaEmbed("#vis-sankey", flowDumbbellSpec, { actions: false, loader: loaderOpts });
  } catch (e) {
    console.error("inline dumbbell embed error", e);
  }

  console.log("embedding age-income grid (9 embeds)...");
  const binnedCsvUrl = (() => { try { return new URL("data/age_income_binned.csv", pageBase).href; } catch { return "data/age_income_binned.csv"; } })();
  const states = ["NSW","VIC","QLD","WA","SA","TAS","ACT","NT","AUS"];
  const baseAgeIncome = {
    $schema: "https://vega.github.io/schema/vega-lite/v5.json",
    autosize: { type: "fit-x", contains: "padding" },
    width: "container",
    height: 240,
    background: "white",
    data: { url: binnedCsvUrl, format: { type: "csv" } },
    transform: [
      { joinaggregate: [{ op: "sum", field: "Count", as: "StateTotal" }] },
      { calculate: "datum.StateTotal > 0 ? datum.Count / datum.StateTotal : 0", as: "Percent" }
    ],
    mark: { type: "rect", stroke: "white", strokeWidth: 0.5 },
    encoding: {
      x: {
        field: "IncomeBin", type: "nominal", title: "Income",
        sort: ["Negative/Nil to $649","$650-$1,499","$1,500-$2,999","$3,000 and above"],
        axis: { labelAngle: 35, labelLimit: 180 }
      },
      y: {
        field: "AgeBin", type: "nominal", title: "Age",
        sort: ["15-24","25-44","45-64","65-84","85 years and over"],
        scale: { domain: ["15-24","25-44","45-64","65-84","85 years and over"], reverse: true }
      },
      color: { field: "Percent", type: "quantitative", title: "Share of state total", scale: { scheme: "tealblues", domain: [0, 0.2], clamp: true }, legend: { format: ".0%" } },
      tooltip: [
        { field: "State", type: "nominal" },
        { field: "AgeBin", type: "nominal", title: "Age group" },
        { field: "IncomeBin", type: "nominal", title: "Income bracket" },
        { field: "Count", type: "quantitative", format: ",", title: "Count" },
        { field: "Percent", type: "quantitative", format: ".1%", title: "Share of state" }
      ]
    },
    config: { view: { stroke: null }, axis: { labelFontSize: 10, titleFontSize: 12 } }
  };
  (async () => {
    for (const s of states) {
      const spec = JSON.parse(JSON.stringify(baseAgeIncome));
      spec.title = s;
      spec.transform = [{ filter: `datum.State == '${s}'` }].concat(spec.transform || []);
      const target = `#vis-age-income-${s}`;
      try {
        await vegaEmbed(target, spec, { actions: false, renderer: 'svg', loader: loaderOpts });
      } catch (e) {
        console.error("age-income embed error for", s, e);
      }
    }
    console.log("age-income grid embed done");
  })();
  // Prefer a lighter TopoJSON if available; fall back to existing spec
  (async () => {
    // Simple projection-scale zoom controls (re-embeds the map)
    let mapBaseSpec = null;
    let mapBaseScale = 850; // default from specs/map.json
    let mapZoom = 1;
    let mapCenter = null; // [lon, lat]
    let mapCentroids = null; // Division -> [lon,lat]
    let stateFit = null; // { AUS: {center:[lon,lat], lonRange, yRange}, NSW: {...}, ... }
    let currentView = null;

    const controls = {
      in: document.getElementById('map-zoom-in'),
      out: document.getElementById('map-zoom-out'),
      reset: document.getElementById('map-zoom-reset')
    };

    function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }
    async function renderMap() {
      if (!mapBaseSpec) return;
      const spec = deepClone(mapBaseSpec);
      try {
        if (!spec.projection) spec.projection = { type: 'mercator', center: [134, -26], scale: mapBaseScale };
        const base = typeof spec.projection.scale === 'number' ? spec.projection.scale : mapBaseScale;
        spec.projection.scale = Math.max(200, Math.min(8000, base * mapZoom));
        if (Array.isArray(mapCenter) && mapCenter.length === 2) {
          spec.projection.center = mapCenter;
        }
      } catch {}
      const res = await vegaEmbed("#vis", spec, { actions: false, loader: loaderOpts });
      currentView = res && res.view ? res.view : null;
      wireViewHandlers();
    }
    function wireControls(){
      if (!controls.in || controls.in.dataset.bound) return; // already wired
      controls.in.addEventListener('click', () => { mapZoom *= 1.25; renderMap(); });
      controls.out.addEventListener('click', () => { mapZoom /= 1.25; renderMap(); });
      controls.reset.addEventListener('click', () => { mapZoom = 1; renderMap(); });
      const sel = document.getElementById('map-fit-state');
      if (sel) {
        sel.addEventListener('change', () => {
          const v = sel.value || 'AUS';
          fitToState(v);
        });
      }
      controls.in.dataset.bound = '1';
      controls.out.dataset.bound = '1';
      controls.reset.dataset.bound = '1';
    }

    // Scroll-wheel zoom disabled; use buttons or click-to-zoom

    // Click-to-zoom: recenter on clicked division
    function wireViewHandlers(){
      if (!currentView || currentView.__clickBound) return;
      const handler = (event, item) => {
        try {
          const d = item && item.datum ? item.datum : null;
          const name = d && (d.DivisionNameGeo || d.properties && d.properties.Elect_div);
          if (!name || !mapCentroids) return;
          const c = mapCentroids[name];
          if (!c) return;
          mapCenter = c;
          mapZoom = Math.min(8, mapZoom * 1.6);
          renderMap();
        } catch {}
      };
      currentView.addEventListener('click', handler);
      currentView.__clickBound = true;
    }

    // Prepare centroids for recentering by division name
    async function prepareCentroids(){
      if (mapCentroids) return mapCentroids;
      try {
        const url = new URL('data/ced_2021.geojson', pageBase).href;
        const res = await fetch(url, { cache: 'no-cache' });
        if (!res.ok) return null;
        const gj = await res.json();
        const feats = Array.isArray(gj.features) ? gj.features : [];
        const out = {};
        // Build division->state map from CSV
        let divToState = {};
        try {
          const csvUrl = new URL('data/tpp_2022.csv', pageBase).href;
          const csvRes = await fetch(csvUrl, { cache: 'no-cache' });
          if (csvRes.ok) {
            const text = await csvRes.text();
            const rows = text.split(/\r?\n/).filter(Boolean);
            const header = rows.shift();
            const cols = header.split(',');
            const iDiv = cols.indexOf('DivisionNm');
            const iState = cols.indexOf('StateAb');
            const split = (line) => line.match(/\"[^\"]*\"|[^,]+/g).map(s => s.replace(/^\"|\"$/g,''));
            for (const line of rows) {
              const parts = split(line);
              if (parts[iDiv] && parts[iState]) divToState[parts[iDiv]] = parts[iState];
            }
          }
        } catch {}

        // Track bounds for AUS and for each state
        const bounds = { AUS: { lonMin: 180, lonMax: -180, latMin: 90, latMax: -90 } };
        for (const code of ['NSW','VIC','QLD','WA','SA','TAS','ACT','NT']) {
          bounds[code] = { lonMin: 180, lonMax: -180, latMin: 90, latMax: -90 };
        }

        for (const f of feats) {
          const name = f && f.properties && (f.properties.Elect_div || f.properties.DivisionNm);
          const g = f && f.geometry;
          const c = centroidLngLat(g);
          if (name && c) out[name] = c;
          // expand overall and per-state bounds
          const update = (B, lon, lat) => {
            if (lon < B.lonMin) B.lonMin = lon;
            if (lon > B.lonMax) B.lonMax = lon;
            if (lat < B.latMin) B.latMin = lat;
            if (lat > B.latMax) B.latMax = lat;
          };
          const walk = (coords) => {
            for (const [lon, lat] of coords) update(bounds.AUS, lon, lat);
          };
          if (g) {
            const code = name && divToState[name];
            const target = code && bounds[code] ? bounds[code] : null;
            if (g.type === 'Polygon') {
              const ring = g.coordinates[0] || [];
              walk(ring);
              if (target) for (const [lon, lat] of ring) update(target, lon, lat);
            } else if (g.type === 'MultiPolygon') {
              for (const poly of g.coordinates) {
                const ring = poly[0] || [];
                walk(ring);
                if (target) for (const [lon, lat] of ring) update(target, lon, lat);
              }
            }
          }
        }
        // Convert bounds to fit metadata
        const toFit = (B) => {
          const lonRange = B.lonMax - B.lonMin;
          const y = (lat) => Math.log(Math.tan(Math.PI/4 + (Math.max(Math.min(lat, 89.9), -89.9) * Math.PI/180)/2));
          const yRange = Math.abs(y(B.latMax) - y(B.latMin));
          const center = [(B.lonMin + B.lonMax)/2, (B.latMin + B.latMax)/2];
          return { center, lonRange, yRange };
        };
        stateFit = {};
        for (const k of Object.keys(bounds)) stateFit[k] = toFit(bounds[k]);
        mapCentroids = out;
      } catch (e) { console.warn('centroid prep failed', e); }
      return mapCentroids;
    }

    function fitToState(code){
      if (!stateFit || !stateFit.AUS) return;
      const au = stateFit.AUS;
      const tgt = stateFit[code] || au;
      mapCenter = tgt.center;
      const pad = 0.90; // leave a little margin
      const ratioLon = au.lonRange / Math.max(0.0001, tgt.lonRange);
      const ratioY = au.yRange / Math.max(0.0001, tgt.yRange);
      const factor = Math.min(ratioLon, ratioY) * pad;
      mapZoom = Math.max(0.1, Math.min(20, factor));
      renderMap();
    }
    function centroidLngLat(geom){
      if (!geom) return null;
      const type = geom.type;
      const coords = geom.coordinates;
      const polyCentroid = (ring) => {
        // ring: [[lon,lat], ...]
        let a = 0, cx = 0, cy = 0;
        for (let i=0, n=ring.length; i<n; i++){
          const [x1,y1] = ring[i];
          const [x2,y2] = ring[(i+1)%n];
          const cross = x1*y2 - x2*y1;
          a += cross;
          cx += (x1 + x2) * cross;
          cy += (y1 + y2) * cross;
        }
        a *= 0.5;
        if (!a) return null;
        return [cx/(6*a), cy/(6*a)];
      };
      if (type === 'Polygon'){
        return polyCentroid(coords[0]);
      } else if (type === 'MultiPolygon'){
        let best = null; let bestArea = -Infinity;
        for (const poly of coords){
          const c = polyCentroid(poly[0]);
          if (c){
            // approximate area by absolute a; recompute
            let a = 0; const ring = poly[0];
            for (let i=0, n=ring.length; i<n; i++){
              const [x1,y1] = ring[i]; const [x2,y2] = ring[(i+1)%n];
              a += (x1*y2 - x2*y1);
            }
            a = Math.abs(a*0.5);
            if (a > bestArea){ bestArea = a; best = c; }
          }
        }
        return best;
      }
      return null;
    }
    try {
      const tryTopo = new URLSearchParams(window.location.search).get("topo") === "1";

      if (tryTopo) {
        const [topoResp, specResp] = await Promise.allSettled([
          fetch("data/ced_2021.topo.json"),
          fetch("specs/map.json?v=3")
        ]);

        let specJson = null;
        if (specResp.status === "fulfilled" && specResp.value.ok) {
          // rewrite any data URLs to absolute
          specJson = await fetchAndRewriteSpec("specs/map.json?v=3");
        }

        if (topoResp.status === "fulfilled" && topoResp.value.ok && specJson) {
          const topo = await topoResp.value.json();
          const layerNames = topo && topo.objects ? Object.keys(topo.objects) : [];
          const featureName = layerNames.length ? layerNames[0] : null;
          if (featureName) {
            specJson.data = {
              url: new URL("data/ced_2021.topo.json", pageBase).href,
              format: { type: "topojson", feature: featureName }
            };
            mapBaseSpec = specJson;
            wireControls();
            await prepareCentroids();
            return renderMap();
          }
        }
        // Fallback to GeoJSON if topo not available/usable
        if (specJson) {
          mapBaseSpec = specJson;
          try { if (mapBaseSpec && mapBaseSpec.projection && typeof mapBaseSpec.projection.scale === 'number') { mapBaseScale = mapBaseSpec.projection.scale; } } catch {}
          wireControls();
          await prepareCentroids();
          return renderMap();
        }
      } else {
        // Default path: do not attempt TopoJSON (avoids 404 noise), just use rewritten GeoJSON spec
        const specJson = await fetchAndRewriteSpec("specs/map.json?v=3");
        mapBaseSpec = specJson;
        try { if (mapBaseSpec && mapBaseSpec.projection && typeof mapBaseSpec.projection.scale === 'number') { mapBaseScale = mapBaseSpec.projection.scale; } } catch {}
        wireControls();
        await prepareCentroids();
        return renderMap();
      }

      // If spec fetch failed entirely, last resort
      return vegaEmbed("#vis", "specs/map.json?v=3", { actions: false });
    } catch (err) {
      console.error("map embed error", err);
    }
  })();


  // ===================== TURNOUT LINE CHART SPEC =====================
  const turnoutSpec = {
    "$schema": "https://vega.github.io/schema/vega-lite/v5.json",
    "width": 1000,
    "height": 420,
    "background": "white",

    "params": [
      {
        "name": "stateFilter_turnout",
        "value": "All",
        "bind": {
          "input": "select",
          "options": ["All","NSW","VIC","QLD","WA","SA","TAS","ACT","NT"],
          "name": "State: "
        }
      }
    ],

    "data": { "url": "data/turnout_by_state.csv?v=14", "format": { "type": "csv" } },

    "transform": [
      { "filter": "stateFilter_turnout == 'All' || datum.State == stateFilter_turnout" }
    ],

    "mark": { "type": "line", "point": true },
    "encoding": {
      "x": { "field": "Year", "type": "quantitative", "title": "Election year" },
      "y": { "field": "TurnoutPct", "type": "quantitative", "title": "Turnout (%)" },
      "color": {
        "field": "State", "type": "nominal", "title": "State/Territory",
        "sort": ["NSW","VIC","QLD","WA","SA","TAS","ACT","NT"],
        "scale": {
          "domain": ["NSW","VIC","QLD","WA","SA","TAS","ACT","NT"],
          "range": ["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#7f7f7f","#ff9da7"]
        }
      },
      "tooltip": [
        { "field": "Year", "type": "quantitative" },
        { "field": "State", "type": "nominal" },
        { "field": "TurnoutPct", "type": "quantitative", "format": ".2f", "title": "Turnout (%)" }
      ]
    },

    "config": {
      "view": { "stroke": null },
      "axis": { "labelFontSize": 11, "titleFontSize": 12 },
      "legend": { "titleFontSize": 12, "labelFontSize": 11 }
    }
  };

  // (moved above with error handlers)
  // Normalize spelling: replace 'Labor' -> 'Labour' in party-aligned labels
  try {
    document.querySelectorAll('.party-alp').forEach(el => {
      if (el && typeof el.textContent === 'string' && el.textContent.trim() === 'Labor') {
        el.textContent = 'Labour';
      }
    });
  } catch {}
  // Fix mojibake in the TPP map paragraph by replacing its HTML content explicitly
  try {
    const p = Array.from(document.querySelectorAll('p')).find(el => (el.textContent||'').startsWith('The map shows how Australians voted'));
    if (p) {
      p.innerHTML = `The map shows how Australians voted in the 2022 federal election, comparing support for the two major political groups — the Australian <strong class="party-alp">Labour</strong> Party (<strong class="party-alp">ALP</strong>) and the Liberal–National <strong class="party-coalition">Coalition</strong>. Each electorate is coloured by the two‑party‑preferred result, which represents which of the two main sides received more votes after preferences were distributed. Shades of red indicate areas where <strong class="party-alp">Labour</strong> gained the majority, while shades of blue show where the <strong class="party-coalition">Coalition</strong> led. By looking across the country, we can see clear patterns: <strong class="party-alp">Labour</strong>'s strength is concentrated in urban and coastal regions, while the <strong class="party-coalition">Coalition</strong> continues to perform strongly in many rural areas. Together, these colours reveal the political landscape that shaped the 2022 outcome and the regional divides within Australia's democracy.`;
    }
  } catch {}
  </script>

  <script>
  // Remove the original TPP paragraph (second <p> in the first viz-section)
  try {
    const firstViz = document.querySelector('.wrap > .viz-section');
    const textDiv = firstViz ? firstViz.querySelector('.grid-two .text') : null;
    if (textDiv) {
      const ps = textDiv.querySelectorAll('p');
      if (ps.length >= 2) ps[1].remove();
    }
  } catch (e) { /* no-op */ }
  </script>

</body>
</html>




